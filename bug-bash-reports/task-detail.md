# Task Detail Bug Report

## Critical

- **BUG-TD-1**: [src/components/task-detail/useTaskDetailState.ts:72-78,80-84,86-92,94-104,106-110] **Stale closure over `subtasks` in all subtask callbacks.** The `subtasks` variable is derived as `todo.subtasks || []` on every render (line 42), but callbacks like `toggleSubtask`, `deleteSubtask`, `updateSubtaskText`, `addManualSubtask`, and `handleAddImportedSubtasks` capture `subtasks` in their `useCallback` dependency arrays. Because `subtasks` is recalculated every render (a new array reference each time `todo.subtasks` is `undefined`), these callbacks will re-create frequently. More importantly, the dependency on `subtasks` means the callback captures the subtasks at the time of the last render, but rapid successive operations (e.g., toggling two subtasks quickly) will cause the second operation to overwrite the first because each callback reads the same stale `subtasks` snapshot. This is a classic race condition where the second toggle reverses the first.

- **BUG-TD-2**: [src/components/layout/TaskDetailPanel.tsx:105-111,114-121] **Missing error handling on `onUpdate`/`onDelete` async calls.** The `handleSaveText` and `handleSaveNotes` functions `await onUpdate(...)` but have no try/catch. If `onUpdate` rejects, the promise is unhandled and `setSaving(false)` is never called (since the error bypasses it), leaving the UI in a permanent "saving" state. The same applies to `handleToggleComplete` (line 123-125), `handlePriorityChange`, `handleStatusChange`, `handleAssigneeChange`, `handleAddSubtask`, `handleToggleSubtask`, `handleDeleteSubtask`. All `await onUpdate(...)` calls lack error handling.

- **BUG-TD-3**: [src/components/layout/TaskDetailPanel.tsx:346-358] **"More options" button is a no-op.** The button with `<MoreHorizontal>` icon at line 347 has `aria-label="More options"` but no `onClick` handler. Clicking it does nothing. This is a broken control that misleads users.

## High

- **BUG-TD-4**: [src/components/task-detail/RecurrenceRow.tsx:8,21] **Type mismatch: `RecurrencePattern` includes `null` but the interface declares `recurrence: RecurrencePattern`.** The `RecurrenceRowProps` declares `recurrence: RecurrencePattern` (which is `'daily' | 'weekly' | 'monthly' | null`). However, on line 21, the `onChange` handler casts `(e.target.value || null) as RecurrencePattern`. When the select's `value` is `null`, React treats it as uncontrolled. The real issue is on line 20: `value={recurrence || ''}` -- this correctly handles `null` for the select value, but the parent in `TaskDetailModal.tsx` (line 119) passes `todo.recurrence ?? null`. Since `RecurrencePattern` = `... | null` and `todo.recurrence` is `RecurrencePattern | undefined`, the `?? null` is correct. But the prop type says `recurrence: RecurrencePattern` (not `RecurrencePattern | null`), and the cast on line 21 forces `''` to be treated as `null` which then gets passed as `RecurrencePattern`. This works by accident but the typing is misleading -- an empty string cast to `RecurrencePattern` is technically incorrect.

- **BUG-TD-5**: [src/components/task-detail/SubtaskItem.tsx:16,70] **`editText` state initializes from `subtask.text` but never syncs when `subtask.text` changes externally.** If a subtask's text is updated via real-time sync (another user editing it), the local `editText` state (initialized on mount via `useState(subtask.text)`) will be stale. When the user then clicks to edit, they will see the old text. There is no `useEffect` to sync `editText` with `subtask.text` prop changes.

- **BUG-TD-6**: [src/components/layout/TaskDetailPanel.tsx:99-103] **State sync uses `task.id` as dependency which may not trigger re-sync.** The `useEffect` on line 100 has `[task.id, task.text, task.notes]` as dependencies. If `task.text` changes while `isEditingText` is true, the effect runs and overwrites the user's edit in progress. Unlike `useTaskDetailState.ts` which guards with `if (!editingText)`, this component has no such guard. Editing text while another user simultaneously updates the task title will clobber the local edit.

- **BUG-TD-7**: [src/components/AttachmentList.tsx:59] **Incorrect type cast: `attachment.file_type as AttachmentCategory`.** The `Attachment` interface defines `file_type: string`, and the actual values stored come from `ALLOWED_ATTACHMENT_TYPES[mimeType].category` which is a string like `'document'`, `'image'`, etc. However, `file_type` could contain any string if the data is malformed or migrated. Casting to `AttachmentCategory` without validation means an unrecognized `file_type` value will silently fall through to the `|| File` fallback for icon but could cause issues with `categoryColors` returning `undefined` styles.

- **BUG-TD-8**: [src/components/SaveTemplateModal.tsx:95] **Hardcoded dark/light background colors instead of CSS variables.** The modal uses `bg-slate-800` (dark) and `bg-white` (light) as hardcoded Tailwind classes instead of the app's CSS variable system (`--surface`, `--foreground`, etc.). Similarly throughout the component: `border-slate-700`, `border-slate-200`, `text-slate-300`, `bg-slate-700`, etc. This will break in any theme beyond simple light/dark, and is inconsistent with the rest of the app that uses CSS variables.

- **BUG-TD-9**: [src/components/CustomerEmailModal.tsx:249] **Missing `role="dialog"` and `aria-modal="true"` on the outer container.** The outer `<div>` at line 250 lacks `role="dialog"` and `aria-modal="true"`. While `SaveTemplateModal` correctly adds these attributes, `CustomerEmailModal` does not, which means screen readers may not announce it as a modal dialog.

## Medium

- **BUG-TD-10**: [src/components/task-detail/SubtaskItem.tsx:89] **Edit button hidden by `opacity-0 group-hover:opacity-100` on desktop, but also `sm:opacity-100`.** The classes are `opacity-0 group-hover:opacity-100 sm:opacity-100`. This means on mobile (`< sm`), the edit button is always invisible (`opacity-0`) and only appears on hover, which is impossible on touch devices. The `sm:opacity-100` makes it visible on tablet+ screens, but on small mobile the edit button is completely inaccessible unless the user happens to long-press. The text `onClick` on the span (line 70) provides an alternative, but this is not discoverable.

- **BUG-TD-11**: [src/components/layout/TaskDetailPanel.tsx:1054] **Delete button uses `window.confirm()` which breaks in SSR and looks jarring.** The delete flow in `TaskDetailPanel` uses `window.confirm('Are you sure...')` (line 1054), which is a browser native dialog. This is inconsistent with `TaskDetailModal`/`TaskDetailFooter` which uses a custom inline confirmation UI. It also cannot be styled and is inaccessible on some mobile browsers.

- **BUG-TD-12**: [src/components/layout/TaskDetailPanel.tsx:550] **Due date input directly calls `onUpdate` without `await` or error handling.** On line 551-553, the `onChange` handler calls `onUpdate(task.id, { due_date: ... })` directly without awaiting the promise or wrapping in try/catch. If it fails, the error is unhandled.

- **BUG-TD-13**: [src/components/layout/TaskCard.tsx:167-170] **`handleMobileMetadataToggle` uses `e.stopPropagation()` on touch event but the actual toggle button uses `onClick`.** The `handleMobileMetadataToggle` callback is created for `TouchEvent` but it is never used as an `onTouchStart` or `onTouchEnd` handler anywhere in the JSX. The mobile metadata toggle button (line 353-368) only uses `onClick`. The `handleMobileMetadataToggle` callback is dead code.

- **BUG-TD-14**: [src/components/task-detail/useTaskDetailState.ts:37-39] **Notes sync effect has no guard for active editing.** Unlike the text sync (which guards with `if (!editingText)`), the notes sync runs unconditionally: `setNotes(todo.notes || '')`. If a user is actively typing in the notes textarea and a real-time update arrives that changes `todo.notes`, the user's in-progress edits will be silently overwritten.

- **BUG-TD-15**: [src/components/task-detail/MetadataSection.tsx:99] **`<label>` wrapping `<span>` with `flex` layout is a `block` element with `flex` display.** The label at line 99 has `className="... block flex items-center gap-1.5"` -- both `block` and `flex` are applied. Tailwind's `flex` will override `block`, so this works by accident, but it is contradictory and confusing.

- **BUG-TD-16**: [src/components/task-detail/NotesSection.tsx:22] **Notes save only triggers on blur, no explicit save button.** The `onSaveNotes` callback is only called via `onBlur`. If the user types notes and then the modal is closed (e.g., Escape key, clicking outside), the blur event may not fire reliably on all browsers/devices, causing data loss. The `TaskDetailModal` wraps notes in a section that only renders if `onUpdateNotes` is provided, but there is no explicit "Save" button for notes.

- **BUG-TD-17**: [src/components/CustomerEmailModal.tsx:219-227] **`document.execCommand('copy')` is deprecated.** The fallback clipboard copy mechanism uses the deprecated `document.execCommand('copy')`. Modern browsers are removing support for this API.

- **BUG-TD-18**: [src/components/layout/TaskDetailPanel.tsx:273] **Potential crash if `task.priority` is undefined.** Line 273 accesses `PRIORITY_CONFIG[task.priority]` but unlike the modal components which use `todo.priority || 'medium'`, this component does not provide a fallback. If `task.priority` is somehow undefined (e.g., data migration, malformed data), this would return `undefined` and the `priorityConfig.color` access on line 502 would throw.

## Low

- **BUG-TD-19**: [src/components/task-detail/useTaskDetailState.ts:2] **Unused type import `PRIORITY_CONFIG`.** Line 2 imports `type { ..., PRIORITY_CONFIG }` as a type import, but `PRIORITY_CONFIG` is a value, not a type. The actual value import is on line 3: `import { PRIORITY_CONFIG as PriorityConfig }`. The type import of `PRIORITY_CONFIG` on line 2 is dead code.

- **BUG-TD-20**: [src/components/layout/TaskCard.tsx:146] **Redundant ternary in `dueDateInfo` color.** Line 146: `color: darkMode ? 'var(--text-muted)' : 'var(--text-muted)'` -- the dark and light values are identical, so the ternary is pointless.

- **BUG-TD-21**: [src/components/layout/TaskDetailPanel.tsx:136] **`handleAssigneeChange` converts empty string to null but then sets it to empty string.** Line 136: `onUpdate(task.id, { assigned_to: assignedTo || '' })` -- if `assignedTo` is `null` (from the select), this converts it to `''`. But the `Todo` interface has `assigned_to?: string` (optional), so an empty string is semantically different from `undefined`/`null`. The `MetadataSection` in the modal path passes `null` directly, creating inconsistency between the two detail views.

- **BUG-TD-22**: [src/components/AttachmentUpload.tsx:35] **`ALLOWED_ATTACHMENT_TYPES` check uses `in` operator which checks prototype chain.** `if (!(file.type in ALLOWED_ATTACHMENT_TYPES))` uses the `in` operator. Since `ALLOWED_ATTACHMENT_TYPES` is a plain object declared with `as const`, this works correctly, but `Object.hasOwn()` or `hasOwnProperty` would be more precise.

- **BUG-TD-23**: [src/components/TaskCompletionSummary.tsx:193-201] **Backdrop `onClick` to close is on the outer wrapper which has `aria-hidden="true"`.** The outer `motion.div` has both `onClick={onClose}` and `aria-hidden="true"`. While the inner modal stops propagation, having `aria-hidden` on the element that captures close clicks means screen readers cannot interact with the backdrop to close the modal.

- **BUG-TD-24**: [src/components/layout/TaskCard.tsx:205] **Redundant `role="article"` on `<motion.article>`.** The `<article>` HTML element already has an implicit `article` role. Adding `role="article"` is redundant.

- **BUG-TD-25**: [src/components/task-detail/MetadataSection.tsx:102] **Overdue badge uses hardcoded `text-red-500` instead of CSS variable.** Line 102 uses `text-red-500` Tailwind class instead of `text-[var(--danger)]`, which is inconsistent with the rest of the app's theming approach.

- **BUG-TD-26**: [src/components/task-detail/MetadataSection.tsx:115] **Overdue date input uses `bg-red-50 dark:bg-red-900/10` hardcoded colors.** These should use CSS variable-based styling for consistency. The `dark:` prefix approach is different from the CSS variable approach used throughout most of the app.
